<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NepseAlpha Predictor</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --text-color: #34495e;
            --border-radius: 8px;
            --box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f4f6f9;
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header {
            text-align: center; margin-bottom: 30px;
            padding-bottom: 20px; border-bottom: 1px solid #dde;
        }
        header h1 { margin: 0; font-size: 36px; color: var(--dark-color); }
        #connection-status {
            margin: 10px 0 0; font-size: 14px; font-weight: 500;
            padding: 8px 12px; border-radius: var(--border-radius);
            display: inline-block; transition: all 0.3s ease;
        }
        .status-disconnected { background-color: #f39c12; color: white; }
        .status-connected { background-color: var(--success-color); color: white; }
        .status-error { background-color: var(--danger-color); color: white; }
        .main-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 30px;
        }
        .card {
            background: white; padding: 25px;
            border-radius: var(--border-radius); box-shadow: var(--box-shadow);
        }
        h2 { font-size: 22px; color: var(--dark-color); margin-top: 0; margin-bottom: 20px; }
        .btn {
            display: block; width: 100%; padding: 12px; border: none;
            border-radius: var(--border-radius); font-size: 16px; font-weight: 600;
            color: white; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .btn:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        .btn-primary { background-color: var(--primary-color); }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 600; }
        select {
            width: 100%; padding: 10px; border: 1px solid #ccc;
            border-radius: var(--border-radius); font-size: 14px; background-color: white;
        }
        #data-preview-container { margin-bottom: 20px; }
        #data-preview-container h3 { margin-top: 0; text-align: left; font-size: 16px; color: var(--dark-color); margin-bottom: 10px; }
        .table-wrapper { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: var(--border-radius); }
        #data-preview-table { width: 100%; border-collapse: collapse; }
        #data-preview-table th, #data-preview-table td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; font-size: 12px; white-space: nowrap; }
        #data-preview-table th { background-color: var(--light-color); position: sticky; top: 0; }
        #analysis-result-container { margin-top: 20px; min-height: 50px; }
        #analysis-result { padding: 10px 0; }
        .analysis-item { margin-bottom: 15px; }
        .analysis-item:last-child { margin-bottom: 0; }
        .analysis-item strong { display: block; font-size: 14px; color: var(--dark-color); text-transform: capitalize; }
        .prediction-line { display: flex; align-items: center; gap: 8px; margin-top: 4px; }
        .prediction { font-weight: bold; }
        .prediction.up { color: var(--success-color); }
        .prediction.down { color: var(--danger-color); }
        .percentage { font-size: 12px; font-weight: bold; }
        .percentage.up { color: var(--success-color); }
        .percentage.down { color: var(--danger-color); }
        .confidence-line { display: flex; align-items: center; gap: 8px; font-size: 12px; margin-top: 5px; }
        .confidence-bar-bg { flex-grow: 1; height: 8px; background-color: var(--light-color); border-radius: 4px; overflow: hidden; }
        .confidence-bar-fill { height: 100%; background-color: var(--primary-color); border-radius: 4px; }
        .justification { font-size: 12px; color: #7f8c8d; margin-top: 6px; font-style: italic; }
        #history-list { display: flex; flex-direction: column; gap: 15px; max-height: 600px; overflow-y: auto; padding: 5px; }
        .history-item { background: #fdfdfd; padding: 15px; border-radius: var(--border-radius); border: 1px solid #eee; }
        .history-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .history-item-header h4 { margin: 0; font-size: 18px; color: var(--primary-color); }
        .history-item-header .date { font-size: 11px; color: #7f8c8d; text-align: right; }
        .history-item-body { border-top: 1px solid #eee; padding-top: 10px; }
        .status-text { text-align: center; font-weight: 500; min-height: 20px; color: #7f8c8d; }
        .error-text { color: var(--danger-color); font-weight: bold; padding: 10px; background-color: #fdd; border-radius: var(--border-radius); }
        #loader { border: 4px solid var(--light-color); border-radius: 50%; border-top: 4px solid var(--primary-color); width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; }
        .hidden { display: none !important; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NepseAlpha Predictor</h1>
            <p id="connection-status" class="status-disconnected">Initializing...</p>
        </header>

        <div class="main-content">
            <!-- Analysis Section -->
            <div id="analysis-section" class="card">
                <h2>Analyze Company Data</h2>
                <div class="form-group">
                    <label for="company-select">Select a Company:</label>
                    <select id="company-select" disabled>
                        <option>Waiting for extension connection...</option>
                    </select>
                </div>
                <div id="data-preview-container">
                    <h3>Data Preview (Latest 10 entries)</h3>
                    <div class="table-wrapper">
                        <table id="data-preview-table"></table>
                    </div>
                </div>
                <button id="process-data-btn" class="btn btn-primary" disabled>Analyze with AI</button>
                <div id="analysis-result-container">
                    <div id="loader" class="hidden"></div>
                    <div id="analysis-result"></div>
                </div>
            </div>

            <!-- History Section -->
            <div id="history-section" class="card">
                <h2>Analysis History</h2>
                <div id="history-list">
                    <p class="status-text">Loading history...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- CONFIGURATION ---
        // CRITICAL: Replace with your extension's ID from chrome://extensions
        const EXTENSION_ID = 'YOUR_EXTENSION_ID_HERE'; 
        const GEMINI_API_KEY = 'AIzaSyBqopZ5Q_RKyzYYMI-LmcbSaJwONy16TzU';
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
        let allCompanyData = {};
        let cooldownInterval = null;

        // --- ELEMENT DECLARATIONS ---
        const connectionStatusEl = document.getElementById('connection-status');
        const companySelect = document.getElementById('company-select');
        const dataPreviewTable = document.getElementById('data-preview-table');
        const processDataBtn = document.getElementById('process-data-btn');
        const loader = document.getElementById('loader');
        const analysisResult = document.getElementById('analysis-result');
        const historyList = document.getElementById('history-list');

        // --- ROBUST EXTENSION COMMUNICATION ---
        const checkExtensionConnection = () => {
            if (EXTENSION_ID === 'YOUR_EXTENSION_ID_HERE') {
                updateConnectionStatus('error', 'Configuration Error: Extension ID has not been set in the website code.');
                return;
            }
            if (typeof chrome === 'undefined' || !chrome.runtime || !chrome.runtime.sendMessage) {
                updateConnectionStatus('error', 'Error: Data Collector extension not detected. Please use a Chromium-based browser (like Chrome or Edge) and ensure the extension is installed.');
                return;
            }

            updateConnectionStatus('disconnected', 'Connecting to Data Collector extension...');
            chrome.runtime.sendMessage(EXTENSION_ID, { action: 'get-status' }, (response) => {
                if (chrome.runtime.lastError || !response) {
                    console.error("Connection Error:", chrome.runtime.lastError?.message || "No response from extension.");
                    updateConnectionStatus('error', 'Error: Could not connect to the extension. Please ensure it is installed, enabled, and this website has been reloaded.');
                } else {
                    const { lastCollectionDate, isScrapingActive } = response.data;
                    const statusText = `Connected. Last data collection: ${lastCollectionDate ? new Date(lastCollectionDate).toLocaleString() : 'Never'}. ${isScrapingActive ? '(Collection in progress)' : ''}`;
                    updateConnectionStatus('connected', statusText);
                    fetchDataFromExtension();
                }
            });
        };
        
        const fetchDataFromExtension = () => {
            chrome.runtime.sendMessage(EXTENSION_ID, { action: 'get-all-data' }, (response) => {
                if (chrome.runtime.lastError || !response || response.status !== 'success') {
                    console.error("Data Fetch Error:", chrome.runtime.lastError?.message || "Failed to get data.");
                    companySelect.innerHTML = '<option>Error fetching data</option>';
                } else {
                    allCompanyData = response.data;
                    populateCompanySelector();
                    companySelect.dispatchEvent(new Event('change'));
                }
            });
        };
        
        const updateConnectionStatus = (status, text) => {
            connectionStatusEl.className = `status-${status}`;
            connectionStatusEl.textContent = text;
        };

        // --- UI & DATA HANDLING ---
        const populateCompanySelector = () => {
            const availableCompanies = Object.keys(allCompanyData).map(key => key.replace('nepse_data_', '')).sort();
            companySelect.innerHTML = '';
            if (availableCompanies.length === 0) {
                companySelect.innerHTML = '<option value="">No data collected yet</option>';
                processDataBtn.disabled = true;
                companySelect.disabled = true;
            } else {
                availableCompanies.forEach(company => {
                    const option = document.createElement('option');
                    option.value = company;
                    option.textContent = company;
                    companySelect.appendChild(option);
                });
                processDataBtn.disabled = false;
                companySelect.disabled = false;
            }
        };

        const displayDataPreview = (company) => {
            const data = allCompanyData[`nepse_data_${company}`];
            dataPreviewTable.innerHTML = '';
            if (!data) {
                dataPreviewTable.innerHTML = '<thead><tr><th>No data available for this company.</th></tr></thead>';
                return;
            }
            const lines = data.trim().split('\n');
            const header = lines[0].split(',').map(h => h.replace(/"/g, ''));
            const thead = `<thead><tr>${header.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
            const tbody = `<tbody>${lines.slice(1, 11).map(line => { const values = line.split(',').map(v => v.replace(/"/g, '')); return `<tr>${values.map(v => `<td>${v}</td>`).join('')}</tr>`; }).join('')}</tbody>`;
            dataPreviewTable.innerHTML = thead + tbody;
        };

        const displayHistory = () => {
            const analysisHistory = JSON.parse(localStorage.getItem('analysisHistory') || '[]');
            historyList.innerHTML = '';
            if (analysisHistory.length === 0) {
                historyList.innerHTML = '<p class="status-text">No analysis history found.</p>';
                return;
            }
            analysisHistory.reverse().forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'history-item';
                itemDiv.innerHTML = `<div class="history-item-header"><h4>${item.company}</h4><div class="date">Analyzed: ${new Date(item.analysisDate).toLocaleString()}</div></div><div class="history-item-body">${formatAIResponse(item.analysis)}</div>`;
                historyList.appendChild(itemDiv);
            });
        };

        const saveToHistory = (company, analysis) => {
            let analysisHistory = JSON.parse(localStorage.getItem('analysisHistory') || '[]');
            const newEntry = { company, analysis, analysisDate: new Date().toISOString() };
            analysisHistory.push(newEntry);
            if (analysisHistory.length > 50) analysisHistory.shift();
            localStorage.setItem('analysisHistory', JSON.stringify(analysisHistory));
            displayHistory();
        };

        // --- EVENT LISTENERS & ACTIONS ---
        companySelect.addEventListener('change', () => displayDataPreview(companySelect.value));

        processDataBtn.addEventListener('click', async () => {
            const selectedCompany = companySelect.value;
            if (!selectedCompany) return;

            processDataBtn.disabled = true;
            processDataBtn.textContent = 'Processing...';
            loader.classList.remove('hidden');
            analysisResult.innerHTML = '';

            try {
                const companyData = allCompanyData[`nepse_data_${selectedCompany}`];
                if (!companyData) throw new Error(`No data found for ${selectedCompany}.`);
                const latestPrice = getLatestClosingPrice(companyData);
                if (latestPrice === null) throw new Error("Could not parse the latest price from the data file.");
                const compactData = getCompactData(companyData);
                if (compactData.trim().split('\n').length < 20) {
                    throw new Error(`Insufficient data for analysis (${compactData.trim().split('\n').length - 1} records).`);
                }
                const prediction = await callGeminiAPI(compactData, latestPrice);
                analysisResult.innerHTML = formatAIResponse(prediction);
                saveToHistory(selectedCompany, prediction);
            } catch (error) {
                console.error('Analysis Error:', error);
                analysisResult.innerHTML = `<p class="error-text">${error.message}</p>`;
            } finally {
                loader.classList.add('hidden');
                startCooldownTimer(10);
            }
        });

        const startCooldownTimer = (seconds) => {
            if (cooldownInterval) clearInterval(cooldownInterval);
            let remaining = seconds;
            processDataBtn.disabled = true;
            cooldownInterval = setInterval(() => {
                if (remaining > 0) {
                    processDataBtn.textContent = `Please wait (${remaining--}s)`;
                } else {
                    clearInterval(cooldownInterval);
                    processDataBtn.disabled = false;
                    processDataBtn.textContent = 'Analyze with AI';
                }
            }, 1000);
        };
        
        // --- UTILITY & API FUNCTIONS ---
        const getCompactData = (csvText) => {
            if (!csvText) return '';
            const lines = csvText.trim().split('\n');
            const header = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
            const [dateIndex, closeIndex, volumeIndex] = ['Date', 'Close', 'Volume'].map(h => header.indexOf(h));
            if ([dateIndex, closeIndex, volumeIndex].includes(-1)) return csvText;
            const newHeader = "Date\tClose\tVolume";
            const newLines = lines.slice(1).map(line => {
                if (!line.trim()) return null;
                const values = line.split(',');
                if (values.length < Math.max(dateIndex, closeIndex, volumeIndex) + 1) return null;
                const [date, close, volume] = [values[dateIndex], values[closeIndex], values[volumeIndex]].map(v => (v || '').replace(/"/g, '').trim());
                if (!date || !close || !volume) return null;
                return `${date}\t${close}\t${volume.replace(/,/g, '')}`;
            }).filter(Boolean);
            return newHeader + '\n' + newLines.join('\n');
        };
        
        const getLatestClosingPrice = (csvText) => {
            if (!csvText) return null;
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return null;
            const header = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
            const closeIndex = header.indexOf('Close');
            if (closeIndex === -1) return null;
            const latestDataLine = lines[1].split(',');
            return parseFloat(latestDataLine[closeIndex].replace(/"/g, '').trim());
        };

        const formatAIResponse = (responseText) => {
            if (!responseText) return '<p>No analysis available.</p>';
            try {
                const parsed = typeof responseText === 'string' ? JSON.parse(responseText) : responseText;
                return Object.entries(parsed).map(([timeframe, details]) => {
                    const predClass = details.prediction.toLowerCase().includes('up') ? 'up' : 'down';
                    const percentClass = String(details.percentage_change).startsWith('+') ? 'up' : 'down';
                    return `<div class="analysis-item"><strong>${timeframe.replace(/_/g, ' ')}:</strong><div class="prediction-line"><span class="prediction ${predClass}">${details.prediction} to ~${details.projected_price}</span><span class="percentage ${percentClass}">${details.percentage_change}</span></div><div class="confidence-line"><span>Confidence:</span><div class="confidence-bar-bg"><div class="confidence-bar-fill" style="width: ${details.confidence_percentage}%;"></div></div><span>${details.confidence_percentage}%</span></div><p class="justification">${details.justification}</p></div>`;
                }).join('');
            } catch (e) {
                console.error("Could not parse AI response as JSON:", e, responseText);
                return `<p class="error-text">The AI returned a response in an unexpected format. Please try again.</p>`; 
            }
        };

        const callGeminiAPI = async (data, latestPrice) => {
            const prompt = `Analyze the historical stock data provided below. The most recent closing price is ${latestPrice}. Provide a detailed analysis for multiple timeframes.
RESPONSE FORMAT: You must respond with ONLY a valid JSON object. Do not include any text, notes, or markdown formatting like \`\`\`json before or after the JSON. The root of the object must contain keys: "next_day", "next_week", "next_month", "next_six_months".
Each key's value must be an object with exactly these five keys: "prediction" (string: "Up", "Down", or "Sideways"), "projected_price" (number), "percentage_change" (string, e.g., "+1.5%"), "confidence_percentage" (number, 0-100), and "justification" (string, a brief explanation).
DATA:
${data}`;

            const response = await fetch(GEMINI_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                })
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`API Error ${response.status}: ${errorBody.error.message}`);
            }
            const result = await response.json();
            if (result.candidates && result.candidates.length > 0) {
                return result.candidates[0].content.parts[0].text;
            }
            throw new Error("The AI model did not provide a prediction.");
        };

        // --- INITIALIZATION ---
        checkExtensionConnection();
        displayHistory();
    });
    </script>
</body>
</html>
